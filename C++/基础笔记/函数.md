[TOC]

## 一、函数地址与函数指针

函数地址的获取非常简单，只需要通过函数名（不跟参数）即可。想将函数作为参数传递时，必须传递函数名或函数指针。

函数指针的声明：

```cpp
double pam(int);
double (*pf)(int);
```

在使用指针调用时，有两种方式：

```cpp
double x = (*pf)(4);
double y = pf(5)
```

函数指针一般在将函数作为参数传递时使用。

由于某些函数的参数列表较为复杂，因此在 *C++11* 之后，建议使用 `auto` 自动判断类型来声明。

## 二、函数模板

### 2.1 显式具体化

在使用函数模板时，如果单纯依靠隐式具体化，会导致某些用户自定义类型在函数内部无法很好的被操作。例如如果某个类没有重写 `+` 运算符，而在模板函数中使用了类似 `a + b` 的操作，就会出现问题。

*C++98* 标准给出了一种解决方式：

* 给定的函数名，可以有**非模板函数**、**模板函数**和**显式具体化模板函数**以及他们的重载版本。
* 显式具体化的原型和定义以 `template<>` 打头，并通过名称来指出类型。
* 具体化优先于常规模板，非模板函数优先于具体化和常规模板。
  * 即 **非模板函数** 优先于 **具体化模板** 优先于 **常规模板**。

除了重写 `+` 运算法，还有两种方法，一个是实现非模板方法，另一个就是显式具体化。

例如有一个模板函数：

```cpp
template <class T>
void Swap(T &, T &);
```

有如下的另一个原型：

```cpp
void Swap(Example &, Example &);
```

其实就是利用函数重载，实现非模板函数。因为编译器在选择函数原型时，会优先选择非模板的函数。

如果使用显式具体化实现，则：

```cpp
template <> void Swap<Example>(Example &, Example &);
template <> void Swap(Example &, Example &);
```

上面两个都是显式具体化的正确方法。编译器选择函数原型时，会在常规模板之前，先选择上述具体化模板。

### 2.2 实例化和具体化

实例化和具体化其实根出同源。

> 可能是因为显式实例化和显式具体化不好命名，才搞得这么复杂。

首先，我们先了解函数模板的机制。**代码中的函数模板本身不会生成函数定义**，只是一个用于生成函数定义的方案。编译器**只有在明确特定类型时，才会生成函数定义**，此时得到的是**模板实例**。假设有如下代码：

```cpp
int a = 1;
int b = 2;
Swap(a, b);
```

在之前声明及书写 `Swap()` 内部逻辑时，都没有实例化，而在上述代码中，调用 `Swap(a, b)` 时才会实例化。此时实例化称为**隐式实例化**。

现在 *C++* 还允许**显式实例化**，语法如下：

```cpp
template void Swap<int>(int &, int &);
```

此时编译器会生成一个使用 `int` 类型的实例，在执行时，会优先选择该实例而不是隐式实例化。

和显式具体化对比就可以发现，二者的差别其实不大，最大的区别在于 `template` 之后有无 `<>` 。

> 同一个文件中使用同一种类型的显式实例化和显式具体化将会出错，即二者不能同时使用在同一种数据类型上。

**隐式实例化、显式实例化和显式具体化统称为具体化**。

## 三、函数执行顺序

基本过程如下：

1. 创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。
2. 使用候选函数列表创建可行函数列表。
3. 确定是否有最佳的可行函数，如果有，则使用，否则调用出错。

其中最后一步，才和函数模板和重载相关联，优先顺序如下：

1. 完全匹配，但常规函数优于模板。
2. 可提升转换。
3. 可标准转换。
4. 用户定义的转换。

其中，完全匹配又允许一些 *无关紧要的匹配* 。

| 实参             | 形参                  |
| ---------------- | --------------------- |
| `Type`           | `Type &`              |
| `Type &`         | `Type`                |
| `Type []`        | `Type *`              |
| `Type(arg_list)` | `Type (*) (arg_list)` |
| `Type`           | `const Type`          |
| `Type`           | `volatile Tye`        |
| `Type *`         | `const Type *`        |
| `Type *`         | `volatile Type *`     |

> 其中 `Type` 包含带有引用的类型，上表显式给出引用符号只是为了更好的表示。
