[TOC]

## 一、动画设计

### 1.1 `Mac` 最小化动画效果

##### Qt opengl的作用？

Qt是一个跨平台的GUI应用程序开发框架，它提供了许多用于创建图形用户界面的工具和库。其中，Qt OpenGL是Qt中用于与OpenGL集成的模块。

Qt OpenGL可以让开发者在Qt应用程序中使用OpenGL来创建图形界面。OpenGL是一个跨平台的图形库，它可以让开发者使用高效的方式创建3D图形和动画。使用Qt OpenGL，开发者可以轻松地将OpenGL集成到他们的Qt应用程序中，从而创建出更加生动、交互性更强的用户界面。

Qt OpenGL还提供了一些额外的功能，如OpenGL窗口管理、纹理管理、着色器管理和顶点缓冲区管理等。这些功能使得开发者能够更加轻松地使用OpenGL来创建高质量的图形效果。

##### 如何通过 Qt 实现 Mac 系统中最小化和还原的动画效果？

在Mac系统中，最小化和还原窗口时会有一个动画效果。在Qt中，可以通过使用QPropertyAnimation类来实现这个动画效果。

下面是一个示例代码，演示如何使用QPropertyAnimation类实现Mac系统中的最小化和还原窗口动画效果：

```
cppCopy code// 最小化窗口动画效果
QPropertyAnimation *animation = new QPropertyAnimation(this, "windowOpacity");
animation->setDuration(500);
animation->setStartValue(1.0);
animation->setEndValue(0.0);
connect(animation, &QPropertyAnimation::finished, this, &QWidget::showMinimized);
animation->start();

// 还原窗口动画效果
QPropertyAnimation *animation = new QPropertyAnimation(this, "windowOpacity");
animation->setDuration(500);
animation->setStartValue(0.0);
animation->setEndValue(1.0);
connect(animation, &QPropertyAnimation::finished, this, &QWidget::showNormal);
animation->start();
```

在这个示例代码中，我们使用了QPropertyAnimation类来创建一个动画效果。我们将窗口的透明度作为动画的属性，使用setStartValue()和setEndValue()方法来设置动画的起始值和结束值，使用setDuration()方法来设置动画的持续时间。

在最小化窗口动画效果中，我们使用了connect()方法将动画的finished()信号连接到了窗口的showMinimized()槽函数上，以便在动画结束后将窗口最小化。

在还原窗口动画效果中，我们使用了connect()方法将动画的finished()信号连接到了窗口的showNormal()槽函数上，以便在动画结束后将窗口还原

## 二、网络

### 2.1 *HTTP* 请求

##### Qt 发送 http 请求并解析？

在 Qt 中发送 HTTP 请求并解析响应可以通过 QNetworkAccessManager 和 QNetworkReply 类来实现。以下是一个简单的示例：

```
cppCopy code#include <QCoreApplication>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QUrlQuery>
#include <QJsonDocument>
#include <QJsonObject>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    QNetworkAccessManager manager;
    QUrl url("https://jsonplaceholder.typicode.com/todos/1");
    QNetworkRequest request(url);

    QNetworkReply *reply = manager.get(request);

    QObject::connect(reply, &QNetworkReply::finished, [&]() {
        QByteArray data = reply->readAll();
        QJsonDocument jsonDoc = QJsonDocument::fromJson(data);
        QJsonObject jsonObj = jsonDoc.object();

        qDebug() << "userId:" << jsonObj["userId"].toInt();
        qDebug() << "id:" << jsonObj["id"].toInt();
        qDebug() << "title:" << jsonObj["title"].toString();
        qDebug() << "completed:" << jsonObj["completed"].toBool();

        reply->deleteLater();
        a.quit();
    });

    return a.exec();
}
```

这个示例使用 QNetworkAccessManager 发送了一个 GET 请求，获取了一个 JSON 数据。然后使用 QJsonDocument 和 QJsonObject 类解析 JSON 数据，并输出了其中的一些字段。

需要注意的是，由于 HTTP 请求是异步的，因此我们需要使用信号和槽机制来处理响应。在上面的示例中，我们使用了 lambda 表达式来处理 QNetworkReply::finished 信号。当请求完成时，我们读取响应数据，解析 JSON 数据，并输出一些字段。最后，我们调用 a.quit() 来退出应用程序。

##### 如果我要发送post请求呢？

如果你想发送 POST 请求，可以使用 QNetworkRequest::setHeader() 方法设置请求头，使用 QNetworkAccessManager::post() 方法发送请求。以下是一个简单的示例：

```
cppCopy code#include <QCoreApplication>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QUrlQuery>
#include <QJsonDocument>
#include <QJsonObject>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    QNetworkAccessManager manager;
    QUrl url("https://jsonplaceholder.typicode.com/posts");
    QNetworkRequest request(url);

    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/x-www-form-urlencoded");

    QUrlQuery params;
    params.addQueryItem("userId", "1");
    params.addQueryItem("title", "foo");
    params.addQueryItem("body", "bar");
    QByteArray postData = params.toString(QUrl::FullyEncoded).toUtf8();

    QNetworkReply *reply = manager.post(request, postData);

    QObject::connect(reply, &QNetworkReply::finished, [&]() {
        QByteArray data = reply->readAll();
        QJsonDocument jsonDoc = QJsonDocument::fromJson(data);
        QJsonObject jsonObj = jsonDoc.object();

        qDebug() << "userId:" << jsonObj["userId"].toInt();
        qDebug() << "id:" << jsonObj["id"].toInt();
        qDebug() << "title:" << jsonObj["title"].toString();
        qDebug() << "body:" << jsonObj["body"].toString();

        reply->deleteLater();
        a.quit();
    });

    return a.exec();
}
```

在这个示例中，我们设置了 Content-Type 请求头为 "application/x-www-form-urlencoded"，并使用 QUrlQuery 类构造了 POST 请求的参数。然后，我们将参数转换为 QByteArray 类型的 postData，并使用 QNetworkAccessManager::post() 方法发送请求。最后，我们解析响应数据，输出一些字段。