[TOC]

## 前言

概述没有什么干货，只是介绍一下计算机图形学的一些难点，给一个心理预期。

## 一、图形学问题解决步骤

计算机图形学问题的解决步骤主要分为四步：
$$
Geometry\ \rightarrow\ Algebra\ \rightarrow\ Algorithm\ \rightarrow\ Program
$$

* $Geometry \rightarrow Algebra$ 

  计算机无法理解几何图形，但能够计算几何代数。因此在转换几何图形问题时，最重要的事情就是找到**几何图形的表达式（*Representation*）**，而如何找到最优的表达式也是一个难点。

  此外，除了表示几何图形对象，对图形的几何操作也同样需要转换为对应的**几何代数表达式**。

* $Algebra \rightarrow Algorithm$

  得到几何代数表达式后，下一步就是寻找计算对应等式的算法，这些等式包括计算两条曲线的交点，两条直线是否平行等等几何状态。实际应用中，往往存在极其庞大数量的复杂非线性集合体。

  **符号计算（*Symbolic Computation*）**

  符号计算的结果是使用符号表示，根据不同的参数带入直接可得到值，比如一元二次方程的根，可以直接通过以下两个符号表达式求解：
  $$
  root1 &= 
  \\ root2 &=
  $$
  符号计算的好处是能够给出一个封闭形式的解（类似封装），可以很方便的带入其他表达式，但缺点是极其耗时。

  **数字计算（*Numerical Computation*）**

  根据某些计算方法或理论直接求值，得到具体的数字而非封闭形式的解。这种方法的好处是快，但需要确保精度合适，且某些方法在某些情况可能存在找不到解的情况。

  **估算（*Approximation*）**

  在高阶多项式计算时，没有求根的符号表达式，因此只能通过一些方法估算某些近似解，这时候问题就转移到了*How good is good*。

* $Algorithm \rightarrow Program$

  理论上算法转为程序的过程是不复杂的，但在处理实数精度时仍然很有难度，需要额外注意。

## 二、图形学问题复杂度

算法中，往往使用时间复杂度和空间复杂度来描述一个算法的复杂度，在几何问题中，同样存在描述其复杂度的方法。

> *Adrian Bowyer*和*John Woodwark*提出了三个不同的复杂度评估名词：维度复杂度，分析复杂度和组合问题复杂度。

### 2.1 维度复杂度（*Dimensional Complexity*）

> 点动成线，线动成面，面动成体。

上面是最基本的维度理论，随着维度的增加，几何问题的难度也随之增大。比如二维曲线无法扭曲，但三维曲线可以扭曲，即无法固定在某个平面内，因为三维曲线可能存在某个曲面上。

### 2.2 分析复杂度（*Analytic Complexity*）

即**解析几何**的复杂度，除了有理多项式，还存在各种三角函数、对数函数等。

在一些情况下，仅靠多项式也无法确定具体图形，比如$x^2-y^2-2y-1=0$是一个二次多项式，但几何形状并不是圆锥曲线，而是两条直线，上述表达式可以分解为$(x+y+1)(x-y-1)=0$。

并且某些等式也并非代表某确定的实数点（或实数线、实数体，取决于维度），可能为虚数点。

在高于四阶的多项式求解时，只能根据牛顿迭代法获取近似值，并且只能够得到一个近似解，则：

* 如果该解不是我们需要的解怎么办？
* 即便该解为我们所需要的解，由于计算机表示实数会存在误差，如果我们在求解某个面与某个体的**切点**时，因为误差，导致我们的结果实际是相交或分离，而不是相切怎么办？

### 2.3 组合复杂度（*Combinatorial Complexity*）

组合复杂度可以类比算法设计中的时间复杂度。时间复杂度评估基础运算执行的次数，图形学中的组合复杂度可以理解为系数、变量与阶数的数量。随着维度的增加，变量增多，相应的系数也会增加，根据不同的图形又存在不同阶数的多项式。

## 三、浮点数运算

前面提到过，计算机只能提供有限位数的小数，因此其精确度有限，且由于计算机使用二进制运算，因此十进制的有限小数，转换为二进制浮点数时会变成无限小数。

### 3.1 有效位数丢失

有效位数通常是根据科学计数法的小数部分来计算的，例如 $12.3$ ，浮点数表示法为 $0.123 \times10^2$ ，其有效位数为`3`位；又例如 $0.0001$ ，浮点数表示法为 $0.1\times10^{-3}$ ，其有效位数为`1`位。

计算机中的浮点数按二进制表示，为了提高精度，其尾数部分最左侧省略了`1`，因此通常计算机中的有效位数为尾数的位数加上省略的`1`。在应用时，由于通常使用十进制，因此一般按照二进制精度换算为十进制精度后，十进制精度较小的位数来判断。

> 例如`float`的尾数二进制表示时共`23`位（不计算省略的`1`），换算为十进制为`7~8`位有效数字，则可靠有效数字为`7`位，因此通常认为`float`的有效位数为`7`位。

需要注意区分精度误差、舍入误差和有效位数丢失的概念：

* **精度误差**：浮点数中的精度意指计算机实际可存储的有效位数，超出该精度的部分会被舍弃，称为**精度误差**。

  精度误差通常采用**截断法**。

* **舍入误差**：由于十进制与二进制之间换算的问题，会存在某些十进制可用有限小数表示的数，转换为二进制时为无限小数，此时由于精度误差，会被舍入以限制在精度范围内，这个舍入过程中丢失的误差称为**舍入误差**，舍入误差根据舍入方法的不同，误差大小也会不同。

  同样的，舍入误差也会存在与浮点数加减运算中，当两个浮点数的有效位数相同，但指数不同时，由于加减运算需要对齐小数部分，因此该过程会出现舍入误差。

  舍入误差通常采用**四舍五入**的方式。

* **有效位数丢失**：有效位数丢失通常发生在运算过程中，若运算结果的有效位数比原数的有效位数少，则该次运算出现**有效位数丢失**。

> 精度误差与舍入误差是不可避免的，因此浮点数运算可能会导致误差扩大，因此一般建议使用高精度表示法或转换为整数进行运算（转换为整数为类型下降，需要注意避免溢出）。
>
> 有效位数丢失是可以避免的，计算机中的加法、乘法与除法运算不会造成有效位数丢失，但减法会产生有效位数丢失，因此应尽量减少减法的使用。

有如下表达式：
$$
0.1001+0.00012=0.10022\\
0.1235-0.02345=0.10005
$$
假设某个计算机的浮点数精度为`4`位，则上述结算结果变为：
$$
\begin{align}
&0.1001+0.00012=0.1002\\
&0.1235-0.02345=0.1
\end{align}
$$
可以看到，运算时会产生精度误差和舍入误差，但加法运算未丢失有效位数；而减法运算会导致运算结果的有效位数变为`1`位（原计算结果为`5`位）。

> 浮点数中的精度就是计算机实际可存储的有效位数，超出该精度的有效位数会被舍弃，称为有效位数丢失。

### 3.2 数学定律失效

由于精度有限，浮点数存在精度误差和舍入误差，甚至存在有效位数丢失，而整型则存在溢出问题，因此在计算机中，常见的数学定律将会失效，例如结合律、交换律、结合律、分配律等等。

## 参考文献

[*Dr. C.K. Shene, Unit 1 of The Geometry Notes of Michigan Technological University.*](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/)
